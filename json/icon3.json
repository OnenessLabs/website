{"history":[{"local":{"id":"7196913f-5f84-4010-8337-f77d76ee6a25","watches":0,"propertiesToWatch":["translateX","translateY","size","fitToCanvas","rotation","opacity","trackMouse","mouseMomentum","axisTilt"],"initialBreakpoint":"Mobile","canvas":{},"ctx":{}},"breakpoints":[{"name":"Desktop","max":null,"min":992,"props":{}},{"name":"Tablet","max":991,"min":576,"props":{}},{"name":"Mobile","max":575,"min":0,"props":{}}],"visible":true,"locked":false,"aspectRatio":1,"layerName":"Background","isElement":true,"opacity":1,"displace":0.5,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"layerType":"image","imageLoaded":false,"effects":[],"size":0.25,"rotation":0,"height":1080,"fitToCanvas":1,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/iJopzwRFncb5zxyp6RmUwHQ9qyX2/Untitled design.jpeg","thumb":"https://assets.unicorn.studio/images/iJopzwRFncb5zxyp6RmUwHQ9qyX2/Untitled design_@thumbnail.jpg?authuser=0","translateX":0,"translateY":0,"width":1920,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }const float STEPS = 24.0; const float PI = 3.1415926;vec3 refrakt(vec3 eyeVector, vec3 normal, float iorRatio) { float dotProduct = dot(eyeVector, normal); float k = 1.0 - iorRatio * iorRatio * (1.0 - dotProduct * dotProduct); if (k < 0.0) { return reflect(eyeVector, normal); } else { return iorRatio * eyeVector - (iorRatio * dotProduct + sqrt(k)) * normal; } }vec4 displacement (vec2 st, vec4 bg, vec4 color) { if(0.00 == 1.0) { vec2 refraction = refrakt(vec3(vTextureCoord, 0.5), color.rgb, 0.50-0.5).xy; vec2 displaced = vTextureCoord + mix(vec2(0), refraction * 0.1, 0.50); vec4 bgDisp = texture(uBgTexture, displaced); bgDisp.rgb = bgDisp.rgb; return bgDisp * color.a; } else { vec2 normal = vec2(bg.r * 2.0 - 1.0, bg.g * 2.0 - 1.0) * 0.1; if(0.00 == 1.) { return texture(uTexture, st + normal * 0.50) * texture(uTexture, st + normal * 0.50).a; } else { return texture(uTexture, st + normal * 0.50); } } }vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.00); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);color = displacement(uv, background, color);if (0 > 0) { float originalAlpha = color.a; float blendedAlpha = color.a + background.a * (1.0 - color.a); color.rgb = mix(background.rgb, color.rgb, blendedAlpha); vec3 blendedColor = blend(0, color.rgb, background.rgb); color = mix(background, vec4(blendedColor, originalAlpha), originalAlpha * 1.00); } else { color = mix(background, color/max(color.a, 0.0001), color.a * 1.00); }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"breakpoints":[{"name":"Desktop","max":null,"min":992,"props":{"mouseMomentum":0.22,"trackMouse":0.38}},{"name":"Mobile","max":575,"min":0,"props":{"mouseMomentum":0,"trackMouse":0}}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"sdf_shape","speed":0.55,"trackMouseMove":0,"mouseMomentum":0,"trackMouse":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uTime;uniform float uTrackMouse; uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float torus(vec3 p, vec2 t) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }vec3 getRepeat(vec3 p) { float spacing = (0.00 + 0.06 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.00 + 0.06 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { vec3 adjustedP = p;vec2 twist = vec2(0, 0);adjustedP /= (0.41 + 0.01);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.06 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, uTrackMouse); vec2 axis = vec2(-1. * vec3(0.39749655497265435, 0.43232412717197444, 0.4158).y - 1. + mousePos.y/PI, vec3(0.39749655497265435, 0.43232412717197444, 0.4158).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 1, 0).x * baseTime; float timeY = vec3(0, 1, 0).y * baseTime; float timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.39749655497265435, 0.43232412717197444, 0.4158).z * 2.0 * PI);mat3 animateYMat = rotY(timeY); mat3 animateXMat = rotX(timeX); mat3 animateZMat = rotZ(timeZ);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = animateZMat * animateYMat * animateXMat;adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return torus(p, vec2(1.25, 0.5 * 0.62)); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float fresnelFactor = abs(dot(eyeVector, worldNormal)); float inversefresnelFactor = 1.0 - fresnelFactor; return pow(inversefresnelFactor, power); }vec3 noFrostOrDispersion(vec3 rd, vec3 normal) { float ior = 1.0 / (1.0 + 0.00 * 0.25); vec3 refractedRay = refract(rd, normal, ior); return texture(uTexture, vTextureCoord - refractedRay.xy).rgb; }vec3 calculateNormal(vec3 p, float eps) { vec2 e = vec2(1.0, -1.0) * eps; return normalize( e.xyy * getMergedSDF(p + e.xyy) + e.yyx * getMergedSDF(p + e.yyx) + e.yxy * getMergedSDF(p + e.yxy) + e.xxx * getMergedSDF(p + e.xxx) ); }vec3 sampleTexture(vec3 rd, vec3 normal) {return noFrostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0., getMergedSDF(p) - 0.06) * (0.41 + 0.01); }const int STEPS = 128; const float MAX_DISTANCE = 40.0;vec4 rayMarch(vec3 ro, vec3 rd, float min_dist) {float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0; float antialias_dist = min_dist + min_dist * 0.25;for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); if (distance < min_dist) { entryPoint = currentPos; partialAlpha = 1.0; entryNormal = calculateNormal(entryPoint, min_dist); break; } else if(distance < antialias_dist) { partialAlpha = 0.5; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, distance); }if(traveled < 0.05) { traveled += distance * 0.9; } else { traveled += distance; } if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return vec4(0); }vec4 bg = texture(uTexture, vTextureCoord);vec3 samplePosition = mix(rd, entryPoint, 1.00); vec3 refractionColor = sampleTexture(samplePosition, entryNormal);vec3 lightDir = vec3(((vec2(vec2(0.25, 0.25).x, 1.-vec2(0.25, 0.25).y) - 0.333) * 3.) - vec2(0.5, 0.5), -3.0);float lightAndShadow = dot(entryNormal, lightDir) * 0.25 + 0.25; vec3 lightColor = mix(vec3(1), vec3(0.8392156862745098, 0.7137254901960784, 0.20784313725490197), 1. - 0.00); vec3 fresnelEffect = fresnel(rd, entryNormal, 8.0) * 1.00 * vec3(0.8392156862745098, 0.7137254901960784, 0.20784313725490197); vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 1.00 + 0.01); vec3 specularEffect = specFactor * 1.00 * lightColor; vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(0.8392156862745098, 0.7137254901960784, 0.20784313725490197) * lightAndShadow, 0.00); finalColor += combinedEffects; vec4 outputColor = mix(bg, vec4(finalColor, 1.0), partialAlpha);return outputColor; }out vec4 fragColor;void main() { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5);float mdist = 4. / uResolution.y; vec4 col = rayMarch(viewDir, rd, mdist); float dither = (rand(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}}],"options":{"name":"3d Shapes","fps":60,"dpi":2,"scale":1,"includeLogo":false,"isProduction":false,"version":"1.3.0"},"version":"1.3.0"}