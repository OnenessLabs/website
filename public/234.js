(window.webpackJsonp=window.webpackJsonp||[]).push([[234],{1281:function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return i}),t(13),t(33);var ve=t(594),u=t(1262),z="#define GLSLIFY 1\nuniform vec3 color1;\nuniform vec3 color2;\n\nuniform int type;\n\nvarying float vCLOSEPLANE;\nvarying float vFARPLANE;\nvarying float vSizeOffset;\nvarying float vLife;\n\nvarying vec3 vPosition;\n\nvoid main() {\n\n  vec2 uv = vec2(gl_PointCoord.x, 1. - gl_PointCoord.y);  // particles dont have uv so we do this\n  vec2 cUv = 2. * uv - 1.; // center uv \n\n  float disc = 1. - length(cUv); // make particle circle \n  disc *= vCLOSEPLANE;\n\n  float vf = 1. - smoothstep(0.5, 1., vFARPLANE);\n\n  disc = smoothstep(0., 0.4, disc);\n  disc *= vf;\n\n  vec3 color = disc * mix(color1, color2, vSizeOffset);\n\n  color = mix(vec3(0.), color, vLife); // FADE\n\n  if(type == 4) {\n\n    float f = distance(vPosition.xz, vec2(0., 0.));\n\n    if(distance(vPosition.xz, vec2(0., 0.)) < 0.5) {\n      color = mix(vec3(0.), color, f);\n\n    }\n  }\n\n  gl_FragColor = vec4(vec3(color), 1.);\n\n}\n",f="#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n\treturn mod289_0(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_0(vec3 v) {\n\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289_0(i);\n\tvec4 p = permute_0(permute_0(permute_0(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt_0(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n\n}\n\nvec3 snoiseVec3_0(vec3 x) {\n\n\tfloat s = snoise_0(vec3(x));\n\tfloat s1 = snoise_0(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n\tfloat s2 = snoise_0(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n\tvec3 c = vec3(s, s1, s2);\n\treturn c;\n\n}\n\nvec3 curlNoise(vec3 p) {\n\n\tconst float e = .1;\n\tvec3 dx = vec3(e, 0.0, 0.0);\n\tvec3 dy = vec3(0.0, e, 0.0);\n\tvec3 dz = vec3(0.0, 0.0, e);\n\n\tvec3 p_x0 = snoiseVec3_0(p - dx);\n\tvec3 p_x1 = snoiseVec3_0(p + dx);\n\tvec3 p_y0 = snoiseVec3_0(p - dy);\n\tvec3 p_y1 = snoiseVec3_0(p + dy);\n\tvec3 p_z0 = snoiseVec3_0(p - dz);\n\tvec3 p_z1 = snoiseVec3_0(p + dz);\n\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(vec3(x, y, z) * divisor);\n\n}\n\nvec3 curlNoise2(vec3 p) {\n\n\tconst float e = .1;\n\n\tvec3 xNoisePotentialDerivatives = snoiseVec3_0(p);\n\tvec3 yNoisePotentialDerivatives = snoiseVec3_0(p + e * vec3(3., -3., 1.));\n\tvec3 zNoisePotentialDerivatives = snoiseVec3_0(p + e * vec3(2., 4., -3.));\n\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\treturn normalize(noiseVelocity);\n\n}\n\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy;\n\tvec3 x3 = x0 - D.yyy;\n\n\ti = mod289_0(i);\n\tvec4 p = permute_0(permute_0(permute_0(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\tvec4 norm = taylorInvSqrt_0(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\tvec4 values = vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)); //value of contributions from each corner (extrapolate the gradient)\n\n\tvec4 m = max(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); //kernel function from each corner\n\n\tvec4 m2 = m * m;\n\tvec4 m3 = m * m * m;\n\n\tvec4 temp = -6.0 * m2 * values;\n\tfloat dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\n\tfloat dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\n\tfloat dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\n\n\treturn vec4(dot(m3, values), dx, dy, dz) * 42.0;\n}\n\nvec3 curlNoise3(vec3 p) {\n\n\tvec3 xNoisePotentialDerivatives = snoiseD(p).yzw; //yzw are the xyz derivatives\n\tvec3 yNoisePotentialDerivatives = snoiseD(vec3(p.y - 19.1, p.z + 33.4, p.x + 47.2)).zwy;\n\tvec3 zNoisePotentialDerivatives = snoiseD(vec3(p.z + 74.2, p.x - 124.5, p.y + 99.4)).wyz;\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\tconst float e = .1;\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(noiseVelocity * divisor);\n\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x) {\n\treturn mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r){\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1(vec3 v) {\n\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\tconst vec4  D_0 = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy) );\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n\tvec3 g_0 = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g_0;\n\tvec3 i1 = min( g_0.xyz, l.zxy );\n\tvec3 i2 = max( g_0.xyz, l.zxy );\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D_0.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289_1(i);\n\tvec4 p = permute_1( permute_1( permute_1(\n\t\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D_0.wyz - D_0.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\tvec4 a1_0 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\tvec3 p0_0 = vec3(a0.xy,h.x);\n\tvec3 p1 = vec3(a0.zw,h.y);\n\tvec3 p2 = vec3(a1_0.xy,h.z);\n\tvec3 p3 = vec3(a1_0.zw,h.w);\n\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt_1(vec4(dot(p0_0,p0_0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0_0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0_0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n\n}\n\nvec3 snoiseVec3_1( vec3 x ){\n\n\tfloat s  = snoise_1(vec3( x ));\n\tfloat s1 = snoise_1(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n\tfloat s2 = snoise_1(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n\tvec3 c = vec3( s , s1 , s2 );\n\treturn c;\n\n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec3 mousePoint;\nuniform sampler2D positionTexture;\nuniform sampler2D velocityTexture;\nuniform float uRatio;\nuniform float uParticleSize;\nuniform int type;\n\nattribute vec2 reference;\nattribute float sizeOffset;\n\n#define PI 3.1415926538\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nvarying float vParticleSize;\nvarying vec3 vVelocity;\n\nuniform float CLOSEPLANE;\nuniform float FARPLANE;\n\nvarying float vCLOSEPLANE;\nvarying float vFARPLANE;\nvarying float vSizeOffset;\nvarying float vLife;\n\nvoid main() {\n\n  vSizeOffset = sizeOffset;\n\n  vec4 posTx = texture2D(positionTexture, reference);\n  vec3 pos = posTx.xyz;\n  vLife = posTx.w;\n\n  if(type == 0) {\n\n    pos.x = mix(pos.x, pos.x * 3., smoothstep(-5., 5., pos.z));\n\n  }\n\n  vec4 worldPosition = modelMatrix * vec4(pos, 1.0);\n\n  // moue\n  float dist = 1.;\n  float uMouseArea = .2;\n  vec2 seg = worldPosition.xy - mousePoint.xy;\n  dist = length(vec2(seg.x, seg.y) * (6. * uMouseArea));\n  //\n\n  vec3 velocity = normalize(texture2D(velocityTexture, reference).xyz);\n\n  if(type == 2) {\n    pos += snoiseVec3_1(pos) * 0.5;\n  }\n\n  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n\n  vPosition = pos;\n  vUv = reference;\n  vVelocity = velocity;\n\n  float particleSize = curlNoise3(pos * 5.).r * 0.5 + 0.5;\n  particleSize *= uParticleSize;\n  vParticleSize = particleSize;\n\n  gl_Position = projectionMatrix * mvPosition;\n\n  vFARPLANE = gl_Position.z / FARPLANE; // max(0.1, FARPLANE); // do not divide by w\n  vCLOSEPLANE = gl_Position.z / CLOSEPLANE; // max(0.1, CLOSEPLANE);\n\n  float vc = smoothstep(0., 0.5, vCLOSEPLANE);\n  vc = max(vc, 0.1);\n\n  float pSize = uParticleSize / vc;\n  gl_PointSize = pSize * ((1. * uRatio) * 0.2 / uRatio);\n\n}\n",v=t(79),o=t(80),c=(t(885),t(3),t(887),t(888),t(889),t(890),t(891),t(892),t(893),t(894),t(895),t(896),t(897),t(898),t(899),t(900),t(901),t(902),t(903),t(904),t(905),t(906),t(907),t(908),t(909),t(910),t(1261)),r="#define GLSLIFY 1\n#define PI 3.1415926538\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 tmpPos = texture2D(texturePosition, uv);\n  vec3 position = tmpPos.xyz;\n\n  vec3 velocity = texture2D(textureVelocity, uv).xyz;\n\n  float x = 0.;\n  float y = 0.;\n  float z = 0.;\n\n  float n = resolution.x;\n  vec2 uuv = gl_FragCoord.xy;\n\n  float u = (uuv.x * 2. * PI) / n;\n  float v = (uuv.y * 2. * PI) / n;\n\n  u += velocity.x;\n\n  x = ((13. / 10.) + sin(u)) * cos(v);\n  z = ((13. / 10.) + sin(u)) * sin(v);\n  y = cos(u);\n\n  position = vec3(x, y, z);\n\n  if(length(position) > 2.) {\n    position = vec3(2., 0., 1.);\n  }\n\n  gl_FragColor = vec4(position, 1.);\n}\n",s="#define GLSLIFY 1\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 tmpVel = texture2D(textureVelocity, uv);\n\n  vec3 z = tmpVel.xyz;\n\n  z += vec3(0.001, 0., 0.);\n\n  gl_FragColor = vec4(z, 1.);\n\n}\n",x=(t(1260),function(e){for(var n,t=[],o=Math.sqrt(e.length/4),i=0,v=0;v<=o;v++)for(var c=0;c<o;c++){var r=Math.sin,s=Math.cos,x=2*v*Math.PI/o,a=2*c*Math.PI/o,y={x:(n=[x*s(x),x*r(x),a])[0],y:n[1],z:n[2]},l=y.x,p=y.y,m=y.z;t.push(new ve.P(l,p,m)),e[i]=l,e[i+1]=p,e[i+2]=m,e[i+3]=1,i+=4}}),a=function(e,n){for(var t=e.length,o=0,i=0;i<=t;i++){var v=2*Math.random()*Math.PI,c=2*Math.random()-1,r=Math.random(),s=Math.acos(c),x=n*Math.cbrt(r);e[o]=x*Math.sin(s)*Math.cos(v),e[o+1]=x*Math.sin(s)*Math.sin(v),e[o+2]=x*Math.cos(s),e[o+3]=1*Math.random(),o+=4}},d=function(){function i(e,n,t){Object(v.a)(this,i),this.WIDTH=n,this.renderer=e;var o=[{pos:"#define GLSLIFY 1\n#define d ( 1.0 / 60.0 )\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 tmpPos = texture2D(texturePosition, uv);\n  vec3 position = tmpPos.xyz;\n\n  vec3 velocity = texture2D(textureVelocity, uv).xyz;\n\n  if(position.z > 3.) {\n    position.z = -5.;\n  }\n\n  position.z = position.z + velocity.z * d;\n\n  gl_FragColor = vec4(position, 1.);\n}\n",vel:"#define GLSLIFY 1\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n#define d ( 1.0 / 60.0 )\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 tmpPos = texture2D(texturePosition, uv);\n\n  vec3 pos = tmpPos.xyz;\n\n  vec4 tmpVel = texture2D(textureVelocity, uv);\n  vec3 vel2 = tmpVel.xyz;\n\n  vel2 = vec3(0., 0., clamp(rand(pos.xy), 0.4, 0.8));\n\n  vel2 = vec3(0., 0., 0.4);\n\n  vel2.z *= rand(pos.xy) * 2. + 0.1;\n\n  gl_FragColor = vec4(vel2, 1.);\n\n}\n"},{pos:"#define GLSLIFY 1\nuniform float delta;\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 tmpPos = texture2D(texturePosition, uv);\n  vec3 position = tmpPos.xyz;\n\n  vec3 velocity = texture2D(textureVelocity, uv).xyz;\n\n  position.z = mod(position + velocity * delta, 3.).z;\n\n  gl_FragColor = vec4(position, 1.);\n}\n",vel:"#define GLSLIFY 1\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nuniform vec2 mouse;\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 tmpPos = texture2D(texturePosition, uv);\n  vec3 pos = tmpPos.xyz;\n\n  vec4 tmpVel = texture2D(textureVelocity, uv);\n\n  vec3 velocity = tmpVel.xyz;\n\n  velocity = vec3(0., 0, clamp(rand(pos.xy), 0.04, 0.1)) * (abs(mouse.y) + 1.) * 4.;\n\n  gl_FragColor = vec4(velocity, 1.);\n\n}\n"},{pos:r,vel:s},{pos:"#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n\treturn mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute_0(permute_0(permute_0(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt_0(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n\n}\n\nvec3 snoiseVec3(vec3 x) {\n\n\tfloat s = snoise(vec3(x));\n\tfloat s1 = snoise(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n\tfloat s2 = snoise(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n\tvec3 c = vec3(s, s1, s2);\n\treturn c;\n\n}\n\nvec3 curlNoise(vec3 p) {\n\n\tconst float e = .1;\n\tvec3 dx = vec3(e, 0.0, 0.0);\n\tvec3 dy = vec3(0.0, e, 0.0);\n\tvec3 dz = vec3(0.0, 0.0, e);\n\n\tvec3 p_x0 = snoiseVec3(p - dx);\n\tvec3 p_x1 = snoiseVec3(p + dx);\n\tvec3 p_y0 = snoiseVec3(p - dy);\n\tvec3 p_y1 = snoiseVec3(p + dy);\n\tvec3 p_z0 = snoiseVec3(p - dz);\n\tvec3 p_z1 = snoiseVec3(p + dz);\n\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(vec3(x, y, z) * divisor);\n\n}\n\nvec3 curlNoise2(vec3 p) {\n\n\tconst float e = .1;\n\n\tvec3 xNoisePotentialDerivatives = snoiseVec3(p);\n\tvec3 yNoisePotentialDerivatives = snoiseVec3(p + e * vec3(3., -3., 1.));\n\tvec3 zNoisePotentialDerivatives = snoiseVec3(p + e * vec3(2., 4., -3.));\n\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\treturn normalize(noiseVelocity);\n\n}\n\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy;\n\tvec3 x3 = x0 - D.yyy;\n\n\ti = mod289(i);\n\tvec4 p = permute_0(permute_0(permute_0(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\tvec4 norm = taylorInvSqrt_0(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\tvec4 values = vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)); //value of contributions from each corner (extrapolate the gradient)\n\n\tvec4 m = max(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); //kernel function from each corner\n\n\tvec4 m2 = m * m;\n\tvec4 m3 = m * m * m;\n\n\tvec4 temp = -6.0 * m2 * values;\n\tfloat dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\n\tfloat dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\n\tfloat dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\n\n\treturn vec4(dot(m3, values), dx, dy, dz) * 42.0;\n}\n\nvec3 curlNoise3(vec3 p) {\n\n\tvec3 xNoisePotentialDerivatives = snoiseD(p).yzw; //yzw are the xyz derivatives\n\tvec3 yNoisePotentialDerivatives = snoiseD(vec3(p.y - 19.1, p.z + 33.4, p.x + 47.2)).zwy;\n\tvec3 zNoisePotentialDerivatives = snoiseD(vec3(p.z + 74.2, p.x - 124.5, p.y + 99.4)).wyz;\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\tconst float e = .1;\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(noiseVelocity * divisor);\n\n}\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute_1(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt_1(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1(permute_1(ix) + iy);\n  vec4 ixy0 = permute_1(ixy + iz0);\n  vec4 ixy1 = permute_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec3 fbm_vec3_1604150559(vec3 p, float frequency, float offset)\n{\n  return vec3(\n    cnoise((p+vec3(offset))*frequency),\n    cnoise((p+vec3(offset+20.0))*frequency),\n    cnoise((p+vec3(offset-30.0))*frequency)\n  );\n}\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n#define d ( 1.0 / 60.0 )\n\n#define PI 3.1415926538\n\nuniform bool powermode;\n\nuniform float time;\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 pp = texture2D(texturePosition, uv);\n  vec3 ppos = pp.xyz;\n  float life = pp.w;\n\n  vec2 center = vec2(0);\n\n  if(powermode) {\n\n    float x = cos(time);\n    float y = sin(time) * cos(time);\n\n    center = vec2(x, y);\n\n  }\n\n  if(distance(ppos, vec3(center, 0.)) > 0.8) {\n\n    ppos += fbm_vec3_1604150559(ppos, 4., 0.) * 0.002;\n\n    life -= 0.11 * d;\n\n  }\n\n  if(life < 0.1) {\n\n    ppos = vec3(center, 0.);\n    life = rand(ppos.xy) + 1.;\n  }\n\n  vec4 vv = texture2D(textureVelocity, uv);\n  vec3 vVel = vv.xyz;\n\n  ppos += vVel * d * 4.;\n\n  gl_FragColor = vec4(ppos, life);\n}\n",vel:"#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n\treturn mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n\n}\n\nvec3 snoiseVec3(vec3 x) {\n\n\tfloat s = snoise(vec3(x));\n\tfloat s1 = snoise(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n\tfloat s2 = snoise(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n\tvec3 c = vec3(s, s1, s2);\n\treturn c;\n\n}\n\nvec3 curlNoise(vec3 p) {\n\n\tconst float e = .1;\n\tvec3 dx = vec3(e, 0.0, 0.0);\n\tvec3 dy = vec3(0.0, e, 0.0);\n\tvec3 dz = vec3(0.0, 0.0, e);\n\n\tvec3 p_x0 = snoiseVec3(p - dx);\n\tvec3 p_x1 = snoiseVec3(p + dx);\n\tvec3 p_y0 = snoiseVec3(p - dy);\n\tvec3 p_y1 = snoiseVec3(p + dy);\n\tvec3 p_z0 = snoiseVec3(p - dz);\n\tvec3 p_z1 = snoiseVec3(p + dz);\n\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(vec3(x, y, z) * divisor);\n\n}\n\nvec3 curlNoise2(vec3 p) {\n\n\tconst float e = .1;\n\n\tvec3 xNoisePotentialDerivatives = snoiseVec3(p);\n\tvec3 yNoisePotentialDerivatives = snoiseVec3(p + e * vec3(3., -3., 1.));\n\tvec3 zNoisePotentialDerivatives = snoiseVec3(p + e * vec3(2., 4., -3.));\n\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\treturn normalize(noiseVelocity);\n\n}\n\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy;\n\tvec3 x3 = x0 - D.yyy;\n\n\ti = mod289(i);\n\tvec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\tvec4 values = vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)); //value of contributions from each corner (extrapolate the gradient)\n\n\tvec4 m = max(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); //kernel function from each corner\n\n\tvec4 m2 = m * m;\n\tvec4 m3 = m * m * m;\n\n\tvec4 temp = -6.0 * m2 * values;\n\tfloat dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\n\tfloat dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\n\tfloat dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\n\n\treturn vec4(dot(m3, values), dx, dy, dz) * 42.0;\n}\n\nvec3 curlNoise3(vec3 p) {\n\n\tvec3 xNoisePotentialDerivatives = snoiseD(p).yzw; //yzw are the xyz derivatives\n\tvec3 yNoisePotentialDerivatives = snoiseD(vec3(p.y - 19.1, p.z + 33.4, p.x + 47.2)).zwy;\n\tvec3 zNoisePotentialDerivatives = snoiseD(vec3(p.z + 74.2, p.x - 124.5, p.y + 99.4)).wyz;\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\tconst float e = .1;\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(noiseVelocity * divisor);\n\n}\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n#define d ( 1.0 / 60.0 )\n\nuniform float delta;\n\nuniform float time;\n\nuniform vec2 mouse;\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 vv = texture2D(textureVelocity, uv);\n  vec3 vVel = vv.xyz;\n\n  gl_FragColor = vec4(vVel, 1.);\n\n}\n"},{pos:"#define GLSLIFY 1\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute_0(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt_0(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_0(permute_0(ix) + iy);\n  vec4 ixy0 = permute_0(ixy + iz0);\n  vec4 ixy1 = permute_0(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_0(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_0(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec3 fbm_vec3_1540259130(vec3 p, float frequency, float offset)\n{\n  return vec3(\n    cnoise((p+vec3(offset))*frequency),\n    cnoise((p+vec3(offset+20.0))*frequency),\n    cnoise((p+vec3(offset-30.0))*frequency)\n  );\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x) {\n\treturn mod289_0(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_0(vec3 v) {\n\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289_0(i);\n\tvec4 p = permute_1(permute_1(permute_1(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt_1(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n\n}\n\nvec3 snoiseVec3_0(vec3 x) {\n\n\tfloat s = snoise_0(vec3(x));\n\tfloat s1 = snoise_0(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n\tfloat s2 = snoise_0(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n\tvec3 c = vec3(s, s1, s2);\n\treturn c;\n\n}\n\nvec3 curlNoise(vec3 p) {\n\n\tconst float e = .1;\n\tvec3 dx = vec3(e, 0.0, 0.0);\n\tvec3 dy = vec3(0.0, e, 0.0);\n\tvec3 dz = vec3(0.0, 0.0, e);\n\n\tvec3 p_x0 = snoiseVec3_0(p - dx);\n\tvec3 p_x1 = snoiseVec3_0(p + dx);\n\tvec3 p_y0 = snoiseVec3_0(p - dy);\n\tvec3 p_y1 = snoiseVec3_0(p + dy);\n\tvec3 p_z0 = snoiseVec3_0(p - dz);\n\tvec3 p_z1 = snoiseVec3_0(p + dz);\n\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(vec3(x, y, z) * divisor);\n\n}\n\nvec3 curlNoise2(vec3 p) {\n\n\tconst float e = .1;\n\n\tvec3 xNoisePotentialDerivatives = snoiseVec3_0(p);\n\tvec3 yNoisePotentialDerivatives = snoiseVec3_0(p + e * vec3(3., -3., 1.));\n\tvec3 zNoisePotentialDerivatives = snoiseVec3_0(p + e * vec3(2., 4., -3.));\n\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\treturn normalize(noiseVelocity);\n\n}\n\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy;\n\tvec3 x3 = x0 - D.yyy;\n\n\ti = mod289_0(i);\n\tvec4 p = permute_1(permute_1(permute_1(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\tvec4 norm = taylorInvSqrt_1(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\tvec4 values = vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)); //value of contributions from each corner (extrapolate the gradient)\n\n\tvec4 m = max(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); //kernel function from each corner\n\n\tvec4 m2 = m * m;\n\tvec4 m3 = m * m * m;\n\n\tvec4 temp = -6.0 * m2 * values;\n\tfloat dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\n\tfloat dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\n\tfloat dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\n\n\treturn vec4(dot(m3, values), dx, dy, dz) * 42.0;\n}\n\nvec3 curlNoise3(vec3 p) {\n\n\tvec3 xNoisePotentialDerivatives = snoiseD(p).yzw; //yzw are the xyz derivatives\n\tvec3 yNoisePotentialDerivatives = snoiseD(vec3(p.y - 19.1, p.z + 33.4, p.x + 47.2)).zwy;\n\tvec3 zNoisePotentialDerivatives = snoiseD(vec3(p.z + 74.2, p.x - 124.5, p.y + 99.4)).wyz;\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\tconst float e = .1;\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(noiseVelocity * divisor);\n\n}\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2(vec4 x) {\n\treturn mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2(vec4 r){\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1(vec3 v) {\n\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\tconst vec4  D_0 = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy) );\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n\tvec3 g_0 = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g_0;\n\tvec3 i1 = min( g_0.xyz, l.zxy );\n\tvec3 i2 = max( g_0.xyz, l.zxy );\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D_0.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289_1(i);\n\tvec4 p = permute_2( permute_2( permute_2(\n\t\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D_0.wyz - D_0.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\tvec4 a1_0 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\tvec3 p0_0 = vec3(a0.xy,h.x);\n\tvec3 p1 = vec3(a0.zw,h.y);\n\tvec3 p2 = vec3(a1_0.xy,h.z);\n\tvec3 p3 = vec3(a1_0.zw,h.w);\n\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt_2(vec4(dot(p0_0,p0_0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0_0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0_0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n\n}\n\nvec3 snoiseVec3_1( vec3 x ){\n\n\tfloat s  = snoise_1(vec3( x ));\n\tfloat s1 = snoise_1(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n\tfloat s2 = snoise_1(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n\tvec3 c = vec3( s , s1 , s2 );\n\treturn c;\n\n}\n\n#define PI 3.1415926538\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 tmpPos = texture2D(texturePosition, uv);\n  vec3 position = tmpPos.xyz;\n\n  vec3 velocity = texture2D(textureVelocity, uv).xyz;\n\n  float x = 0.;\n  float y = 0.;\n  float z = 0.;\n\n  float n = resolution.x;\n  vec2 uuv = gl_FragCoord.xy;\n\n  float u = (uuv.x) / n;\n\n  u = mix(-PI / 2., PI / 2., u);\n  float v = (uuv.y * 2. * PI) / n;\n\n  v += velocity.x;\n\n  x = (1.5 + sin(u)) * cos(v);\n  z = (1.5 + sin(u)) * sin(v);\n  y = cos(u);\n\n  position = vec3(x, y, z);\n\n  float u2 = (uuv.x * (PI * 4.)) / n;\n\n  float v2 = (uuv.y * 2. * PI) / n;\n\n  u2 -= velocity.x;\n\n  float x2 = sin(v2) * cos(u2);\n  float y2 = sin(v2) * sin(u2);\n  float z2 = cos(v2);\n\n  vec3 newposition = vec3(x2, z2, y2);\n\n  vec3 center = vec3(0., 0.5, 0.);\n\n  if(position.y < 0.5) {\n\n    position = mix(snoiseVec3_1(normalize(newposition)), (center) + (normalize(newposition)) * 0.5, 1.);\n\n  }\n\n  position.xyz *= 1.2;\n\n  gl_FragColor = vec4(position, 1.);\n}\n",vel:"#define GLSLIFY 1\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute_0(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt_0(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_0(permute_0(ix) + iy);\n  vec4 ixy0 = permute_0(ixy + iz0);\n  vec4 ixy1 = permute_0(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_0(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_0(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec3 fbm_vec3_1540259130(vec3 p, float frequency, float offset)\n{\n  return vec3(\n    cnoise((p+vec3(offset))*frequency),\n    cnoise((p+vec3(offset+20.0))*frequency),\n    cnoise((p+vec3(offset-30.0))*frequency)\n  );\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x) {\n\treturn mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute_1(permute_1(permute_1(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt_1(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n\n}\n\nvec3 snoiseVec3(vec3 x) {\n\n\tfloat s = snoise(vec3(x));\n\tfloat s1 = snoise(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n\tfloat s2 = snoise(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n\tvec3 c = vec3(s, s1, s2);\n\treturn c;\n\n}\n\nvec3 curlNoise(vec3 p) {\n\n\tconst float e = .1;\n\tvec3 dx = vec3(e, 0.0, 0.0);\n\tvec3 dy = vec3(0.0, e, 0.0);\n\tvec3 dz = vec3(0.0, 0.0, e);\n\n\tvec3 p_x0 = snoiseVec3(p - dx);\n\tvec3 p_x1 = snoiseVec3(p + dx);\n\tvec3 p_y0 = snoiseVec3(p - dy);\n\tvec3 p_y1 = snoiseVec3(p + dy);\n\tvec3 p_z0 = snoiseVec3(p - dz);\n\tvec3 p_z1 = snoiseVec3(p + dz);\n\n\tfloat x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n\tfloat y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n\tfloat z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(vec3(x, y, z) * divisor);\n\n}\n\nvec3 curlNoise2(vec3 p) {\n\n\tconst float e = .1;\n\n\tvec3 xNoisePotentialDerivatives = snoiseVec3(p);\n\tvec3 yNoisePotentialDerivatives = snoiseVec3(p + e * vec3(3., -3., 1.));\n\tvec3 zNoisePotentialDerivatives = snoiseVec3(p + e * vec3(2., 4., -3.));\n\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\treturn normalize(noiseVelocity);\n\n}\n\nvec4 snoiseD(vec3 v) { //returns vec4(value, dx, dy, dz)\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\tvec3 i = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy;\n\tvec3 x3 = x0 - D.yyy;\n\n\ti = mod289(i);\n\tvec4 p = permute_1(permute_1(permute_1(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);\n\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = y_ * ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\tvec4 norm = taylorInvSqrt_1(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\tvec4 values = vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)); //value of contributions from each corner (extrapolate the gradient)\n\n\tvec4 m = max(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); //kernel function from each corner\n\n\tvec4 m2 = m * m;\n\tvec4 m3 = m * m * m;\n\n\tvec4 temp = -6.0 * m2 * values;\n\tfloat dx = temp[0] * x0.x + temp[1] * x1.x + temp[2] * x2.x + temp[3] * x3.x + m3[0] * p0.x + m3[1] * p1.x + m3[2] * p2.x + m3[3] * p3.x;\n\tfloat dy = temp[0] * x0.y + temp[1] * x1.y + temp[2] * x2.y + temp[3] * x3.y + m3[0] * p0.y + m3[1] * p1.y + m3[2] * p2.y + m3[3] * p3.y;\n\tfloat dz = temp[0] * x0.z + temp[1] * x1.z + temp[2] * x2.z + temp[3] * x3.z + m3[0] * p0.z + m3[1] * p1.z + m3[2] * p2.z + m3[3] * p3.z;\n\n\treturn vec4(dot(m3, values), dx, dy, dz) * 42.0;\n}\n\nvec3 curlNoise3(vec3 p) {\n\n\tvec3 xNoisePotentialDerivatives = snoiseD(p).yzw; //yzw are the xyz derivatives\n\tvec3 yNoisePotentialDerivatives = snoiseD(vec3(p.y - 19.1, p.z + 33.4, p.x + 47.2)).zwy;\n\tvec3 zNoisePotentialDerivatives = snoiseD(vec3(p.z + 74.2, p.x - 124.5, p.y + 99.4)).wyz;\n\tvec3 noiseVelocity = vec3(zNoisePotentialDerivatives.y - yNoisePotentialDerivatives.z, xNoisePotentialDerivatives.z - zNoisePotentialDerivatives.x, yNoisePotentialDerivatives.x - xNoisePotentialDerivatives.y);\n\n\tconst float e = .1;\n\tconst float divisor = 1.0 / (2.0 * e);\n\treturn normalize(noiseVelocity * divisor);\n\n}\n\n#define d ( 1.0 / 60.0 )\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 tmpVel = texture2D(textureVelocity, uv);\n\n  vec3 z = tmpVel.xyz;\n\n  z += vec3(0.1 * rand(uv), 0., 0.) * d;\n\n  gl_FragColor = vec4(z, 1.);\n\n}\n"},{pos:r,vel:s},{pos:"#define GLSLIFY 1\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nuniform float time;\n\n#define PI 3.1415926538\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 velocity = texture2D(textureVelocity, uv);\n\n  float x = 0.;\n  float y = 0.;\n  float z = 0.;\n\n  float n = resolution.x;\n  vec2 uuv = gl_FragCoord.xy;\n\n  float u = (uuv.x * 2. * PI) / n;\n  float v = (uuv.y * 2. * PI) / n;\n\n  v = velocity.x * rand(uv);\n\n  float radius = v;\n  float angle = v * 1.;\n\n  // Calculate particle position on spiral\n  x = radius * cos(angle);\n  y = radius * sin(angle);\n  z = u;\n\n  vec3 position = vec3(x, y, z);\n\n  if(v < 0.) {\n    position = vec3(0., 0., z);\n  }\n\n  gl_FragColor = vec4(position, 1.);\n}\n",vel:"#define GLSLIFY 1\n#define PI 3.1415926538\n\nuniform float time;\n\nvoid main() {\n\n  /// \n\n  float n = resolution.x;\n  vec2 uuv = gl_FragCoord.xy;\n\n  vec4 tv = texture2D(textureVelocity, uuv);\n\n  float vv = (uuv.y * 2. * PI) / n;\n  tv.x = vv;\n\n  float f = tv.x;\n  f += time * 0.5;\n\n  float exit = mod(f, 6.28);\n\n  gl_FragColor = vec4(exit, 1., 1., 1.);\n\n}\n"}];this.type=t||0,this.simPos=o[t||0].pos,this.simVel=o[t||0].vel}return Object(o.a)(i,[{key:"dispose",value:function(){this.gpuCompute.dispose(),this.cubeGeo.dispose(),this.cubeGeoPoins.material.dispose(),this.cubeGeoPoins.geometry.dispose(),this.positionVariable.material.dispose(),this.velocityVariable.material.dispose()}},{key:"initPoints",value:function(e){for(var n=this.WIDTH*this.WIDTH,t=new ve.d,o=new Float32Array(3*n),i=new Float32Array(2*n),v=new Float32Array(n),c=0;c<n;c++){var r=Math.random(),s=Math.random(),x=Math.random(),a=c%this.WIDTH/this.WIDTH,y=~~(c/this.WIDTH)/this.WIDTH;o.set([r,s,x],3*c),i.set([a,y],2*c),v.set([Math.random()],c)}t.setAttribute("position",new ve.c(o,3,!1)),t.setAttribute("reference",new ve.c(i,2,!1)),t.setAttribute("sizeOffset",new ve.c(v,1,!1));var l=new ve.E(t,e);return l.frustumCulled=!0,this.cubeGeo=t,this.cubeGeoPoins=l}},{key:"initGPGPU",value:function(m){this.gpuCompute=new c.a(this.WIDTH,this.WIDTH,this.renderer),!1===this.renderer.capabilities.isWebGL2&&this.gpuCompute.setDataType(ve.o);var e=this.gpuCompute.createTexture();0===this.type?function(e,n){for(var t=m.xml.childNodes[0],o=t.getTotalLength(),i=Math.floor(o/5),v=[],c=0;c<i;c++){var r=o*c/i,s=t.getPointAtLength(r);v.push(new ve.O(.01*s.x,.01*s.y))}for(var x=v,a=v.length,y=0;y<e.length;y+=4){var l=new ve.P(0,0,0),p=Math.floor(Math.random()*a);l.x=x[p].x-1.45+.1*Math.random(),l.y=x[p].y-1.1+.1*Math.random(),l.z=2*Math.random()-10,l.z=8*Math.random()-5,e[y]=l.x,e[y+1]=l.y,e[y+2]=l.z,e[y+3]=1}}(e.image.data):function(e,n){switch(n){case 1:!function(e,n,t){for(var o=e.length,i=0,v=0;v<=o;v++){var c,r=.5*(Math.random()-.5),s=.5*(Math.random()-.5);c=v%2?-t:t,e[i]=r*n,e[i+1]=c,e[i+2]=s*n,e[i+3]=1,i+=4}}(e.image.data,10,.1);break;case 6:x(e.image.data,1);break;case 3:a(e.image.data,1)}}(e,this.type);var n,t=this.gpuCompute.createTexture();n=t,3===this.type?a(n.image.data,.01):function(e){for(var n=e.image.data,t=0,o=n.length;t<o;t+=4)n[t+0]=1*Math.random(),n[t+1]=.1,n[t+2]=.1,n[t+3]=Math.random()}(n),this.positionVariable=this.gpuCompute.addVariable("texturePosition",this.simPos,e),this.velocityVariable=this.gpuCompute.addVariable("textureVelocity",this.simVel,t),this.gpuCompute.setVariableDependencies(this.positionVariable,[this.positionVariable,this.velocityVariable]),this.positionVariable.wrapS=ve.I,this.positionVariable.wrapT=ve.I;var o=this.positionVariable.material.uniforms;return o.delta={value:0},o.scroll={value:0},o.time={value:0},o.powermode={value:!0},this.gpuCompute.setVariableDependencies(this.velocityVariable,[this.positionVariable,this.velocityVariable]),this.velocityVariable.material.uniforms.mouse={value:new ve.O(0)},this.velocityVariable.wrapS=ve.I,this.velocityVariable.wrapT=ve.I,this.velocityVariable.material.uniforms.scroll={value:0},this.velocityVariable.material.uniforms.time={value:0},o.mouse={value:new ve.O(0)},this.gpuCompute.init(),this.last=performance.now(),{filter:null,unif:o,output:e,output2:t,gpuCompute:this.gpuCompute}}},{key:"scroll",value:function(e){this.hasScroll=!0;var n=e.scroll.velocity();this.velocity=n}},{key:"update",value:function(e,n,t){var o=performance.now(),i=(o-this.last)/1e3;if(1<i&&(i=1),this.last=o,this.velocityVariable&&this.hasScroll){var v=this.velocityVariable.material.uniforms.time.value,c=.05*i;this.velocityVariable.material.uniforms.time.value=ve.s.damp(v-c,v-4*this.velocity-c,.1,.01)}this.positionVariable&&(this.positionVariable.material.uniforms.delta.value=i,this.positionVariable.material.uniforms.time.value=n),t&&(this.velocityVariable.material.uniforms.mouse.value=t),this.gpuCompute.compute(),e&&(e.uniforms.positionTexture.value=this.gpuCompute.getCurrentRenderTarget(this.positionVariable).texture),e&&(e.uniforms.velocityTexture.value=this.gpuCompute.getCurrentRenderTarget(this.velocityVariable).texture)}}]),i}(),m=t(14),X=t(16);t(308),t(27),t(151),t(213),t(54),t(37),t(11),t(208),t(324),t(128),t(53),t(129),t(149),t(36),t(42),t(163),t(942);var g=function(e){return function(e){var c={defaultDPI:90,defaultUnit:"px"};function te(e,n,t,o,i,v,c,r){if(0!=n&&0!=t){o=o*Math.PI/180,n=Math.abs(n),t=Math.abs(t);var s=(c.x-r.x)/2,x=(c.y-r.y)/2,a=Math.cos(o)*s+Math.sin(o)*x,y=-Math.sin(o)*s+Math.cos(o)*x,l=n*n,p=t*t,m=a*a,u=y*y,z=m/l+u/p;if(1<z){var f=Math.sqrt(z);l=(n*=f)*n,p=(t*=f)*t}var d=l*u+p*m,g=(l*p-d)/d,h=Math.sqrt(Math.max(0,g));i===v&&(h=-h);var _=h*n*y/t,P=-h*t*a/n,b=Math.cos(o)*_-Math.sin(o)*P+(c.x+r.x)/2,w=Math.sin(o)*_+Math.cos(o)*P+(c.y+r.y)/2,D=N(1,0,(a-_)/n,(y-P)/t),C=N((a-_)/n,(y-P)/t,(-a-_)/n,(-y-P)/t)%(2*Math.PI);e.currentPath.absellipse(b,w,n,t,D,D+C,0===v,o)}else e.lineTo(r.x,r.y)}function N(e,n,t,o){var i=e*t+n*o,v=Math.sqrt(e*e+n*n)*Math.sqrt(t*t+o*o),c=Math.acos(Math.max(-1,Math.min(1,i/v)));return e*o-n*t<0&&(c=-c),c}function V(o,i){i=Object.assign({},i);var v={};if(o.hasAttribute("class"))for(var e=o.getAttribute("class").split(/\s/).filter(Boolean).map(function(e){return e.trim()}),n=0;n<e.length;n++)v=Object.assign(v,O["."+e[n]]);function t(e,n,t){void 0===t&&(t=function(e){return e.startsWith("url"),e}),o.hasAttribute(e)&&(i[n]=t(o.getAttribute(e))),v[e]&&(i[n]=t(v[e])),o.style&&""!==o.style[e]&&(i[n]=t(o.style[e]))}function c(e){return Math.max(0,Math.min(1,S(e)))}function r(e){return Math.max(0,S(e))}return o.hasAttribute("id")&&(v=Object.assign(v,O["#"+o.getAttribute("id")])),t("fill","fill"),t("fill-opacity","fillOpacity",c),t("fill-rule","fillRule"),t("opacity","opacity",c),t("stroke","stroke"),t("stroke-opacity","strokeOpacity",c),t("stroke-width","strokeWidth",r),t("stroke-linejoin","strokeLineJoin"),t("stroke-linecap","strokeLineCap"),t("stroke-miterlimit","strokeMiterLimit",r),t("visibility","visibility"),i}function oe(e,n){return e-(n-e)}function ie(e,n,t){if("string"!=typeof e)throw new TypeError("Invalid input: "+Object(m.a)(e));var o,i={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/},v=0,c=!0,r="",s="",x=[];function a(e,n,t){var o=new SyntaxError('Unexpected character "'+e+'" at index '+n+".");throw o.partial=t,o}function y(){""!==r&&(""===s?x.push(Number(r)):x.push(Number(r)*Math.pow(10,Number(s)))),s=r=""}for(var l=e.length,p=0;p<l;p++)if(o=e[p],Array.isArray(n)&&n.includes(x.length%t)&&i.FLAGS.test(o))v=1,r=o,y();else{if(0===v){if(i.WHITESPACE.test(o))continue;if(i.DIGIT.test(o)||i.SIGN.test(o)){v=1,r=o;continue}if(i.POINT.test(o)){v=2,r=o;continue}i.COMMA.test(o)&&(c&&a(o,p,x),c=!0)}if(1===v){if(i.DIGIT.test(o)){r+=o;continue}if(i.POINT.test(o)){r+=o,v=2;continue}if(i.EXP.test(o)){v=3;continue}i.SIGN.test(o)&&1===r.length&&i.SIGN.test(r[0])&&a(o,p,x)}if(2===v){if(i.DIGIT.test(o)){r+=o;continue}if(i.EXP.test(o)){v=3;continue}i.POINT.test(o)&&"."===r[r.length-1]&&a(o,p,x)}if(3===v){if(i.DIGIT.test(o)){s+=o;continue}if(i.SIGN.test(o)){if(""===s){s+=o;continue}1===s.length&&i.SIGN.test(s)&&a(o,p,x)}}i.WHITESPACE.test(o)?(y(),v=0,c=!1):i.COMMA.test(o)?(y(),c=!(v=0)):i.SIGN.test(o)?(y(),v=1,r=o):i.POINT.test(o)?(y(),v=2,r=o):a(o,p,x)}return y(),x}var r=["mm","cm","in","pt","pc","px"],s={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:12,pc:1,px:-1},px:{px:1}};function S(e){var n="px";if("string"==typeof e||e instanceof String)for(var t=0,o=r.length;t<o;t++){var i=r[t];if(e.endsWith(i)){n=i,e=e.substring(0,e.length-i.length);break}}var v=void 0;return"px"===n&&"px"!==c.defaultUnit?v=s.in[c.defaultUnit]/c.defaultDPI:(v=s[n][c.defaultUnit])<0&&(v=s[n].in*c.defaultDPI),v*parseFloat(e)}function T(e){var n=e.elements;return n[0]*n[4]-n[1]*n[3]<0}function E(e){var n=e.elements,t=n[0]*n[3]+n[1]*n[4];if(0===t)return!1;var o=F(e),i=k(e);return Math.abs(t/(o*i))>Number.EPSILON}function F(e){var n=e.elements;return Math.sqrt(n[0]*n[0]+n[1]*n[1])}function k(e){var n=e.elements;return Math.sqrt(n[3]*n[3]+n[4]*n[4])}var j=[],O={},q=[],G=new ve.t,R=new ve.t,W=new ve.t,Y=new ve.t,H=new ve.O,U=new ve.P,B=new ve.t,n=(new DOMParser).parseFromString(e,"image/svg+xml");return function e(n,t){if(1===n.nodeType){var o=function(e){if(!(e.hasAttribute("transform")||"use"===e.nodeName&&(e.hasAttribute("x")||e.hasAttribute("y"))))return null;var n=function(e){var n=new ve.t,t=G;if("use"===e.nodeName&&(e.hasAttribute("x")||e.hasAttribute("y"))){var o=S(e.getAttribute("x")),i=S(e.getAttribute("y"));n.translate(o,i)}if(e.hasAttribute("transform"))for(var v=e.getAttribute("transform").split(")"),c=v.length-1;0<=c;c--){var r=v[c].trim();if(""!==r){var s=r.indexOf("("),x=r.length;if(0<s&&s<x){var a=r.slice(0,s),y=ie(r.slice(s+1));switch(t.identity(),a){case"translate":if(1<=y.length){var l=y[0],p=0;2<=y.length&&(p=y[1]),t.translate(l,p)}break;case"rotate":if(1<=y.length){var m,u=0,z=0;m=-y[0]*Math.PI/180,3<=y.length&&(u=y[1],z=y[2]),R.identity().translate(-u,-z),W.identity().rotate(m),Y.multiplyMatrices(W,R),R.identity().translate(u,z),t.multiplyMatrices(R,Y)}break;case"scale":if(1<=y.length){var f=y[0],d=f;2<=y.length&&(d=y[1]),t.scale(f,d)}break;case"skewX":1===y.length&&t.set(1,Math.tan(y[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":1===y.length&&t.set(1,0,0,Math.tan(y[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":6===y.length&&t.set(y[0],y[2],y[4],y[1],y[3],y[5],0,0,1)}}n.premultiply(t)}}return n}(e);return 0<q.length&&n.premultiply(q[q.length-1]),B.copy(n),q.push(n),n}(n),i=!1,a=null;switch(n.nodeName){case"svg":case"g":t=V(n,t);break;case"style":!function(e){if(e.sheet&&e.sheet.cssRules&&e.sheet.cssRules.length)for(var n=0;n<e.sheet.cssRules.length;n++){var t=e.sheet.cssRules[n];if(1===t.type)for(var o=t.selectorText.split(/,/gm).filter(Boolean).map(function(e){return e.trim()}),i=0;i<o.length;i++){var v=Object.fromEntries(Object.entries(t.style).filter(function(e){return""!==Object(X.a)(e,2)[1]}));O[o[i]]=Object.assign(O[o[i]]||{},v)}}}(n);break;case"path":t=V(n,t),n.hasAttribute("d")&&(a=function(e){for(var n=new ve.L,t=new ve.O,o=new ve.O,i=new ve.O,v=!0,c=!1,r=e.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi),s=0,x=r.length;s<x;s++){var a=r[s],y=a.charAt(0),l=a.slice(1).trim();!0===v&&(v=!(c=!0));var p=void 0;switch(y){case"M":for(var m=0,u=(p=ie(l)).length;m<u;m+=2)t.x=p[m+0],t.y=p[m+1],o.x=t.x,o.y=t.y,0===m?n.moveTo(t.x,t.y):n.lineTo(t.x,t.y),0===m&&i.copy(t);break;case"H":for(var z=0,f=(p=ie(l)).length;z<f;z++)t.x=p[z],o.x=t.x,o.y=t.y,n.lineTo(t.x,t.y),0===z&&!0===c&&i.copy(t);break;case"V":for(var d=0,g=(p=ie(l)).length;d<g;d++)t.y=p[d],o.x=t.x,o.y=t.y,n.lineTo(t.x,t.y),0===d&&!0===c&&i.copy(t);break;case"L":for(var h=0,_=(p=ie(l)).length;h<_;h+=2)t.x=p[h+0],t.y=p[h+1],o.x=t.x,o.y=t.y,n.lineTo(t.x,t.y),0===h&&!0===c&&i.copy(t);break;case"C":for(var P=0,b=(p=ie(l)).length;P<b;P+=6)n.bezierCurveTo(p[P+0],p[P+1],p[P+2],p[P+3],p[P+4],p[P+5]),o.x=p[P+2],o.y=p[P+3],t.x=p[P+4],t.y=p[P+5],0===P&&!0===c&&i.copy(t);break;case"S":for(var w=0,D=(p=ie(l)).length;w<D;w+=4)n.bezierCurveTo(oe(t.x,o.x),oe(t.y,o.y),p[w+0],p[w+1],p[w+2],p[w+3]),o.x=p[w+0],o.y=p[w+1],t.x=p[w+2],t.y=p[w+3],0===w&&!0===c&&i.copy(t);break;case"Q":for(var C=0,N=(p=ie(l)).length;C<N;C+=4)n.quadraticCurveTo(p[C+0],p[C+1],p[C+2],p[C+3]),o.x=p[C+0],o.y=p[C+1],t.x=p[C+2],t.y=p[C+3],0===C&&!0===c&&i.copy(t);break;case"T":for(var A=0,I=(p=ie(l)).length;A<I;A+=2){var L=oe(t.x,o.x),M=oe(t.y,o.y);n.quadraticCurveTo(L,M,p[A+0],p[A+1]),o.x=L,o.y=M,t.x=p[A+0],t.y=p[A+1],0===A&&!0===c&&i.copy(t)}break;case"A":for(var V=0,S=(p=ie(l,[3,4],7)).length;V<S;V+=7)if(p[V+5]!=t.x||p[V+6]!=t.y){var T=t.clone();t.x=p[V+5],t.y=p[V+6],o.x=t.x,o.y=t.y,te(n,p[V],p[V+1],p[V+2],p[V+3],p[V+4],T,t),0===V&&!0===c&&i.copy(t)}break;case"m":for(var E=0,F=(p=ie(l)).length;E<F;E+=2)t.x+=p[E+0],t.y+=p[E+1],o.x=t.x,o.y=t.y,0===E?n.moveTo(t.x,t.y):n.lineTo(t.x,t.y),0===E&&i.copy(t);break;case"h":for(var k=0,j=(p=ie(l)).length;k<j;k++)t.x+=p[k],o.x=t.x,o.y=t.y,n.lineTo(t.x,t.y),0===k&&!0===c&&i.copy(t);break;case"v":for(var O=0,q=(p=ie(l)).length;O<q;O++)t.y+=p[O],o.x=t.x,o.y=t.y,n.lineTo(t.x,t.y),0===O&&!0===c&&i.copy(t);break;case"l":for(var G=0,R=(p=ie(l)).length;G<R;G+=2)t.x+=p[G+0],t.y+=p[G+1],o.x=t.x,o.y=t.y,n.lineTo(t.x,t.y),0===G&&!0===c&&i.copy(t);break;case"c":for(var W=0,Y=(p=ie(l)).length;W<Y;W+=6)n.bezierCurveTo(t.x+p[W+0],t.y+p[W+1],t.x+p[W+2],t.y+p[W+3],t.x+p[W+4],t.y+p[W+5]),o.x=t.x+p[W+2],o.y=t.y+p[W+3],t.x+=p[W+4],t.y+=p[W+5],0===W&&!0===c&&i.copy(t);break;case"s":for(var H=0,U=(p=ie(l)).length;H<U;H+=4)n.bezierCurveTo(oe(t.x,o.x),oe(t.y,o.y),t.x+p[H+0],t.y+p[H+1],t.x+p[H+2],t.y+p[H+3]),o.x=t.x+p[H+0],o.y=t.y+p[H+1],t.x+=p[H+2],t.y+=p[H+3],0===H&&!0===c&&i.copy(t);break;case"q":for(var B=0,X=(p=ie(l)).length;B<X;B+=4)n.quadraticCurveTo(t.x+p[B+0],t.y+p[B+1],t.x+p[B+2],t.y+p[B+3]),o.x=t.x+p[B+0],o.y=t.y+p[B+1],t.x+=p[B+2],t.y+=p[B+3],0===B&&!0===c&&i.copy(t);break;case"t":for(var J=0,Q=(p=ie(l)).length;J<Q;J+=2){var Z=oe(t.x,o.x),K=oe(t.y,o.y);n.quadraticCurveTo(Z,K,t.x+p[J+0],t.y+p[J+1]),o.x=Z,o.y=K,t.x=t.x+p[J+0],t.y=t.y+p[J+1],0===J&&!0===c&&i.copy(t)}break;case"a":for(var $=0,ee=(p=ie(l,[3,4],7)).length;$<ee;$+=7)if(0!=p[$+5]||0!=p[$+6]){var ne=t.clone();t.x+=p[$+5],t.y+=p[$+6],o.x=t.x,o.y=t.y,te(n,p[$],p[$+1],p[$+2],p[$+3],p[$+4],ne,t),0===$&&!0===c&&i.copy(t)}break;case"Z":case"z":n.currentPath.autoClose=!0,0<n.currentPath.curves.length&&(t.copy(i),n.currentPath.currentPoint.copy(t),v=!0)}c=!1}return n}(n));break;case"rect":t=V(n,t),w=S((b=n).getAttribute("x")||0),D=S(b.getAttribute("y")||0),C=S(b.getAttribute("rx")||b.getAttribute("ry")||0),N=S(b.getAttribute("ry")||b.getAttribute("rx")||0),A=S(b.getAttribute("width")),I=S(b.getAttribute("height")),L=.448084975506,(M=new ve.L).moveTo(w+C,D),M.lineTo(w+A-C,D),(0!==C||0!==N)&&M.bezierCurveTo(w+A-C*L,D,w+A,D+N*L,w+A,D+N),M.lineTo(w+A,D+I-N),(0!==C||0!==N)&&M.bezierCurveTo(w+A,D+I-N*L,w+A-C*L,D+I,w+A-C,D+I),M.lineTo(w+C,D+I),(0!==C||0!==N)&&M.bezierCurveTo(w+C*L,D+I,w,D+I-N*L,w,D+I-N),M.lineTo(w,D+N),(0!==C||0!==N)&&M.bezierCurveTo(w,D+N*L,w+C*L,D,w+C,D),a=M;break;case"polygon":t=V(n,t),h=n,_=new ve.L,P=0,h.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,function(e,n,t){var o=S(n),i=S(t);0===P?_.moveTo(o,i):_.lineTo(o,i),P++}),_.currentPath.autoClose=!0,a=_;break;case"polyline":t=V(n,t),f=n,d=new ve.L,g=0,f.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,function(e,n,t){var o=S(n),i=S(t);0===g?d.moveTo(o,i):d.lineTo(o,i),g++}),d.currentPath.autoClose=!1,a=d;break;case"circle":t=V(n,t),a=function(e){var n=S(e.getAttribute("cx")||0),t=S(e.getAttribute("cy")||0),o=S(e.getAttribute("r")||0),i=new ve.B;i.absarc(n,t,o,0,2*Math.PI);var v=new ve.L;return v.subPaths.push(i),v}(n);break;case"ellipse":t=V(n,t),a=function(e){var n=S(e.getAttribute("cx")||0),t=S(e.getAttribute("cy")||0),o=S(e.getAttribute("rx")||0),i=S(e.getAttribute("ry")||0),v=new ve.B;v.absellipse(n,t,o,i,0,2*Math.PI);var c=new ve.L;return c.subPaths.push(v),c}(n);break;case"line":t=V(n,t),l=S((y=n).getAttribute("x1")||0),p=S(y.getAttribute("y1")||0),m=S(y.getAttribute("x2")||0),u=S(y.getAttribute("y2")||0),(z=new ve.L).moveTo(l,p),z.lineTo(m,u),z.currentPath.autoClose=!1,a=z;break;case"defs":i=!0;break;case"use":t=V(n,t);var v=(n.getAttributeNS("http://www.w3.org/1999/xlink","href")||"").substring(1),c=n.viewportElement.getElementById(v);c&&e(c,t)}a&&(void 0!==t.fill&&"none"!==t.fill&&a.color.setStyle(t.fill),function(e,L){function n(e){U.set(e.x,e.y,1).applyMatrix3(L),e.set(U.x,U.y)}function t(e){var n,t,o,i,v,c,r,s,x,a,y,l=e.xRadius,p=e.yRadius,m=Math.cos(e.aRotation),u=Math.sin(e.aRotation),z=new ve.P(l*m,l*u,0),f=new ve.P(-p*u,p*m,0),d=z.applyMatrix3(L),g=f.applyMatrix3(L),h=G.set(d.x,g.x,0,d.y,g.y,0,0,0,1),_=R.copy(h).invert(),P=W.copy(_).transpose().multiply(_).elements,b=(n=P[0],t=P[1],o=P[4],x=n+o,a=n-o,y=Math.sqrt(a*a+4*t*t),0<x?v=n*(s=1/(i=.5*(x+y)))*o-t*s*t:x<0?v=.5*(x-y):(i=.5*y,v=-.5*y),c=0<a?a+y:a-y,Math.abs(c)>2*Math.abs(t)?c=(s=-2*t/c)*(r=1/Math.sqrt(1+s*s)):0===Math.abs(t)?(c=1,r=0):r=(s=-.5*c/t)*(c=1/Math.sqrt(1+s*s)),0<a&&(s=c,c=-r,r=s),{rt1:i,rt2:v,cs:c,sn:r}),w=Math.sqrt(b.rt1),D=Math.sqrt(b.rt2);if(e.xRadius=1/w,e.yRadius=1/D,e.aRotation=Math.atan2(b.sn,b.cs),!((e.aEndAngle-e.aStartAngle)%(2*Math.PI)<Number.EPSILON)){var C=R.set(w,0,0,0,D,0,0,0,1),N=W.set(b.cs,b.sn,0,-b.sn,b.cs,0,0,0,1),A=C.multiply(N).multiply(h),I=function(e){var n=new ve.P(Math.cos(e),Math.sin(e),0).applyMatrix3(A),t=n.x,o=n.y;return Math.atan2(o,t)};e.aStartAngle=I(e.aStartAngle),e.aEndAngle=I(e.aEndAngle),T(L)&&(e.aClockwise=!e.aClockwise)}}function o(e){var n=F(L),t=k(L);e.xRadius*=n,e.yRadius*=t;var o=n>Number.EPSILON?Math.atan2(L.elements[1],L.elements[0]):Math.atan2(-L.elements[3],L.elements[4]);e.aRotation+=o,T(L)&&(e.aStartAngle*=-1,e.aEndAngle*=-1,e.aClockwise=!e.aClockwise)}for(var i=a.subPaths,v=0,c=i.length;v<c;v++)for(var r=i[v].curves,s=0;s<r.length;s++){var x=r[s];x.isLineCurve?(n(x.v1),n(x.v2)):x.isCubicBezierCurve?(n(x.v0),n(x.v1),n(x.v2),n(x.v3)):x.isQuadraticBezierCurve?(n(x.v0),n(x.v1),n(x.v2)):x.isEllipseCurve&&(H.set(x.aX,x.aY),n(H),x.aX=H.x,x.aY=H.y,E(L)?t(x):o(x))}}(0,B),j.push(a),a.userData={node:n,style:t});for(var r=n.childNodes,s=0;s<r.length;s++){var x=r[s];i&&"style"!==x.nodeName&&"defs"!==x.nodeName||e(x,t)}o&&(q.pop(),0<q.length?B.copy(q[q.length-1]):B.identity())}var y,l,p,m,u,z,f,d,g,h,_,P,b,w,D,C,N,A,I,L,M}(n.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:j,xml:n.documentElement}}(e)};function i(t,e,n){var o=e.renderer,i=e.scene,v=e.camera,c=(e.controls,e.scroller),r=new ve.K({uniforms:{mouse:{value:new ve.O(0)},mousePoint:{value:new ve.P(0)},type:{value:0},positionTexture:{value:null},velocityTexture:{value:null},time:{value:0},uRatio:{value:Math.min(window.devicePixelRatio,2)},uParticleSize:{value:16},color1:{value:new ve.h("#afffc5")},color2:{value:new ve.h("#5aa3ff")},CLOSEPLANE:{value:5.35},FARPLANE:{value:6.58}},transparent:!1,depthWrite:!1,depthTest:!1,blending:ve.a,vertexShader:f,fragmentShader:z}),s=192;(!0===n.isMobile||n.fps<40)&&(s=128);var x=null,a=null,y=null,l=t;0===l&&(y=g("")),x=new d(o,s,l),a=x.initPoints(r),x.initGPGPU(y),5===(a.material.uniforms.type.value=l)&&(a.rotation.z=Math.PI/3,v.position.z=1.5,r.uniforms.FARPLANE.value=2.07,r.uniforms.CLOSEPLANE.value=2.97),2===l&&(a.rotation.z=Math.PI/3,v.position.z=1.5,r.uniforms.FARPLANE.value=2.56,r.uniforms.CLOSEPLANE.value=2.97),0===l&&(v.position.z=3,r.uniforms.FARPLANE.value=6,r.uniforms.CLOSEPLANE.value=6.58),4===l&&(a.rotation.x=Math.PI/3.8,a.rotation.z=Math.PI/16,a.position.y=-.3,v.position.z=2.2,r.uniforms.FARPLANE.value=2.5,r.uniforms.CLOSEPLANE.value=1.74),1===l&&(r.uniforms.FARPLANE.value=3.3),3===l&&(v.position.z=1.5,r.uniforms.FARPLANE.value=2.2,r.uniforms.CLOSEPLANE.value=2.89,a.rotation.set(2.1768,-.0168,.0992)),i.add(a);var p=new u.a(v,o.domElement);p.size=.75,p.space="local",p.attach(a),p.setMode("rotate"),p.showX=!1,p.showY=!1,p.showZ=!1,i.add(p);var m=new ve.P(0,0,0);return{object3D:a,useFrame:function(e,n,t){x.update(r,e,n),c.scroll&&x.scroll(c),r.uniforms.time.value=e,2!==l&&0!==l&&3!==l&&4!==l&&5!==l||!n?1===l&&n&&(a.rotation.z+=4*-n.x*.001,a.scale.y=ve.s.lerp(a.scale.y,.8*(Math.abs(n.y)+1),.1)):(t.position.lerp({x:.4*-n.x,y:.2*-n.y,z:t.position.z},.1),t.lookAt(m),t.updateProjectionMatrix())},handleResize:function(){a.material.uniforms.uRatio.value=Math.min(window.devicePixelRatio,2)},useGui:function(n){n.transformControls=p;var e={count:s*s,color1:"#afffc5",color2:"#5aa3ff",active:t,trans:function(){"rotate"===p.mode?p.setMode("translate"):p.setMode("rotate")},save:function(){var e=n.save();localStorage.setItem("gui",JSON.stringify(e))},load:function(){n.load(JSON.parse(localStorage.getItem("gui")))}};n.add(e,"count",0,e.count,1).onChange(function(e){a.geometry.setDrawRange(0,e)}),n.add(a.material.uniforms.uParticleSize,"value",1,100,.01).name("particle size"),n.addColor(e,"color1").onChange(function(e){a.material.uniforms.color1.value=new ve.h(e)}),n.addColor(e,"color2").onChange(function(e){a.material.uniforms.color2.value=new ve.h(e)}),n.add(a.material.uniforms.FARPLANE,"value",0,20,.01).name("FARPLANE"),n.add(a.material.uniforms.CLOSEPLANE,"value",0,100,.01).name("CLOSEPLANE"),n.add(e,"trans").name("rotate / translate")},dispose:function(){x.dispose(),a.material.dispose(),a.geometry.dispose(),p.dispose()}}}}}]);